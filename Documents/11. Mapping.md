### Introduction 
- Mapping defines the structure of documents and how they are indexed and stored. This includes the fields of a document and their data types. As a simplification, you can think of it as the equivalent of a table schema in a relational database.
```JSON
PUT /freelancer
{
    "mappings":{
        "properties":{
           "id": { type: "keyword" },
            "business_name": { type: 'text' },
            "is_active": { type: 'boolean' },
            "location": { type: 'geo_shape' },
            "work_days": { type: 'text' },
            "avg_rating": { type: "double" },
            "avg_category_price": { type: "double" },
        }
    }
}
```
- In Elasticsearch, there are two basic approaches to mapping; explicit and dynamic mapping.
- With explicit mapping, we define fields and their data types ourselves, typically when
creating an index.
- Dynamic Mapping - To make Elasticsearch easier to use, a field mapping will automatically be created when
Elasticsearch encounters a new field.
It will inspect the supplied field value to figure out how the field should be mapped.
If you supply a string value, for instance, Elasticsearch will use the “text” data
type for the mapping.

### Overview of Data Types 
- The normal data types including objects, boolean, double etc. There are some specialised data structures such as ip for storing ip addresses and some more like geospatial ones. 

### Object 
This document may then contain a field with an object as its value.
This object may then contain an inner object itself, forming an object hierarchy.
In other words, we can nest objects.
The way this is mapped, is that a “properties” key is added for objects instead of specifying
the “type” key as with other data types.
Example: 
```JSON
{
    ...
    "address":{
        "properties": {
            "road":{"type":"text"},
            ""city":{"type":"text"}
        }
    }
}
```

So actually we can nest objects withing objects by just specifying the properties key.

- we just defined objects as regular JSON objects when we index documents, that’s
actually not how the objects are stored internally.  
Apache Lucene, does not support objects.  
That’s why Elasticsearch transforms inner objects to a format that is compatible with
Lucene, as part of indexing operations.  
The way the objects are stored internally, is that they are flattened.  
Each level in the hierarchy is denoted with a dot, such that there are no longer any objects,
but the hierarchy is maintained.
This is how objects are flattend.
```JSON
{
    "address.road":{"type":"text"},
    "address.city":{"type":"text"}
}
```
<span style="color:yellow;font-size:13px;"> What happens if we try to index an array of objects?</span>
- What happens is that the values are grouped by field name and indexed as an array.
```JSON
{
    "name":"coffe Maker",
    "reviews":[
        {
            "rating": 5.0,
            "description":"Awesome"
        },
        {
            "rating": 4.0,
            "description":"BAD"
        }
    ]
} 
```
This will be saved as 

```
"name":"coffee Maker",
"reviews.rating": [5.0, 4.0],
"reviews.description": ["Awesome","BAD"]
```

- If you run a search query against one of the fields, it will search through all of the
values within the array.
That’s pretty nice in some situations, but it can cause trouble in others.
Let’s look at an example.
Suppose that we want to search for products that have a review left by a person named
John Doe, with a rating of at least 4.    
What will happen, is that the product will match, even though the review left by John
Doe actually has a rating of 3.5.
The reason is that the field values were all mixed together when the document was indexed,so the relationship between the object keys was lost. When this happens, Elasticsearch doesn’t know that there is a relationship between “John Doe” and 3.5.

- To solve this, there is a data type called “nested,” which is a specialized version of the “object” data type. The purpose of it is to maintain the relationship between object values when an array of objects
is indexed.
Using this data type enables us to query objects independently, meaning that the object values  are not mixed together.
``` {"type":"nested"}```

So if the above is ran when the data type of reviews is nested then we will get the expected behaviour.

- As apache lucene does not support objects these objects are stored as hidden documents. The difference is that these documents won’t show up in search results unless we query them directly.  
Suppose that we index a product containing ten reviews, each being a nested object.  
This would cause 11 documents to be indexed into Lucene; one for the product, and one
for each review.

### Keyword DataType 
This data type should be used for fields on which you want to search for exact values.
Since only exact searching is supported, this data type is used for filtering, sorting,
and aggregating documents.  
An example would be to have a “status” field for news articles and search for all
articles that have a value of “published” for the field.

- Use cases for the “keyword” data type,
being filtering, sorting, and aggregations.
But why is its use limited to this?   
\-> we need to dive into how “keyword” fields are analyzed and stored.  
\-> For “keyword” fields, an analyzer named “keyword” is used instead.
This analyzer is actually a so-called no-op analyzer, meaning that it doesn’t do anything.
Well, besides returning the unmodified input string as a single token.
```JSON
POST /_analyze
{
  "text": [
    "Hi", "   Hi this is test", "!!! !!! H!!!",
    "FINE"
    ],
"analyzer": "keyword"
}
```
- It would result in
```JSON
{
  "tokens" : [
    {
      "token" : "Hi",
      "start_offset" : 0,
      "end_offset" : 2,
      "type" : "word",
      "position" : 0
    },
    {
      "token" : "   Hi this is test",
      "start_offset" : 3,
      "end_offset" : 21,
      "type" : "word",
      "position" : 1
    },
    {
      "token" : "!!! !!! H!!!",
      "start_offset" : 22,
      "end_offset" : 34,
      "type" : "word",
      "position" : 2
    },
    {
      "token" : "FINE",
      "start_offset" : 35,
      "end_offset" : 39,
      "type" : "word",
      "position" : 3
    }
  ]
}

```
- The strings are left entirely untouched and is just returned as a single token.  
The “keyword” analyzer does not remove
any symbols from the string, and neither does it lowercase letters.

- Realistic use case would be to map something like e-mail addresses or article
statuses as a “keyword” field.
Example: 
```JSON
{
    "name":"Bo ANdersen",
    "email":"testBo@Bo.com"
}
{
    "name":"Ben",
    "email":"testbeno@Bo.com"
}
{
    "name":"Bo Asen",
    "email":"teo@Bo.com"
}
```
Inverted Index for email field in these documents would be 
```
Term             | Document1   Document2   Document3
----------------------------------------------------------
testBo@Bo.com    |     *
testbeno@Bo.com  |                *
teo@Bo.com       |                            *
```

