### Arrays in Elastic Search 

- An array doesn't exist for elastic search. That’s because any field in Elasticsearch may contain zero or more values by default. That’s right - you can index an array of values without defining this within the field’s mapping.

- While the datatype remains the same without any sign of array in datatype. How is it stored? 
\-> We can index an array of values without defining this within the field’s mapping  
In the case of text fields, the strings are simply concatenated before being analyzed,
and the resulting tokens are stored within an inverted index as normal.
```JS
{
POST /_analyze
{
    "text": ["hI","THIS"], 
}

```
If we analyze this we have 
```
{
  "tokens" : [
    {
      "token" : "hi",
      "start_offset" : 0,
      "end_offset" : 2,
      "type" : "<ALPHANUM>",
      "position" : 0
    },
    {
      "token" : "this",
      "start_offset" : 3,
      "end_offset" : 7,
      "type" : "<ALPHANUM>",
      "position" : 1
    }
  ]
}
```
- we can see that the results contain tokens from both strings. Notice the character offsets for the last two tokens, originating from the second string. The offsets don’t start over from zero, but rather continue from the last offset of the first string. This means that the strings are indeed treated as a single string and not as multiple values.
- the strings are concatenated with a space in-between, because otherwise the words “simply” and “merged” would end up within the same token.
- In the case of non-text fields, the values are not analyzed, and multiple values are just stored within the appropriate data structure within Apache Lucene.

- All of the values within the array must be of the same data type. This means that you cannot mix strings and integers together in the same array, for instance.

- It’s also possible to index nested arrays,
```
[1,[2,3]]  -> [1,2,3]
```
Supplying such an array will cause Elasticsearch to flatten it, i.e. to move any nested array values up to the top level.