### Introduction

- Apart from specifying a field’s data type, there are also some parameters available that configure the behavior of fields in various ways.

- The first parameter is the one named “format.”
This parameter is used to specify a date format when you want to index dates that are not
formatted in the default format.

```JSON
PUT /reviews
{
  "mappings": {
    "properties": {
      "author": {
        "properties": {
          "firstname":{"type": "text"},
          "lastname":{"type": "text"},
          "email":{"type": "keyword"}
        }
      },
      "rating": {"type": "float"},
      "content": {"type": "text"},
      "product_id": {"type":"integer"},
      "created_at":{
          "type":"date",
          "format": "dd/MM/yyyy"
            }
    }
  }
}
```

- The next one is the "properties" parameter. We use it both at the top level when defining mappings, and for nested fields. To be clear, nested fields can be for both fields of the “object” and “nested” data types.

- The next one is "coercion". The parameter lets you enable or disable type coercion. It’s enabled by default, but that might not always be desirable.  
If we were to supply a string value for the “product_id” field, Elasticsearch would reject the document.

```JSON
PUT /reviews
{
  "mappings": {
    "properties": {
      "author": {
        "properties": {
          "firstname":{"type": "text"},
          "lastname":{"type": "text"},
          "email":{"type": "keyword"}
        }
      },
      "rating": {"type": "float"},
      "content": {"type": "text"},
      "product_id": {
          "type":"integer",
          "coerce": "false"
          },
      "created_at":{
          "type":"date",
          "format": "dd/MM/yyyy"
            }
    }
  }
}
```
It’s also possible to configure coercion at the index level so you don’t have to
specify the “coercion” parameter for every field.
```JSON
PUT /reviews
{
    "settings": {
        "index.mapping.coerce" : false
},
  "mappings": {
    "properties": {
      "author": {
        "properties": {
          "firstname":{"type": "text"},
          "lastname":{"type": "text"},
          "email":{"type": "keyword"}
        }
      }
```

- Next is a parameter named "doc_values". We have seen what an inverted index is and how that is used to efficiently resolve which
documents contain a given term. Also this is not the only data structure used for fields. That’s because there is no single data structure that efficiently serves all purposes.  
For instance, while an inverted index is excellent for searching for terms, it doesn’t perform well for most other use cases.  
There is more to queries than simply searching for data; perhaps we want to sort the results
alphabetically, or to aggregate values.
These are two examples of when an inverted index does not perform well, because the access
pattern is different.
Instead of looking up terms and finding the documents that contain them, we need to look
up the document and find its terms for a field.
This is what the “doc values” data structure is; pretty much the opposite of an inverted index.

- Besides being used for sorting and aggregations, this data structure is also used when accessing field values from within scripts.  To be clear, the “doc values” data structure is not a replacement for an inverted index,
but rather an addition to it, meaning that both data structures will be maintained for a field at the same time.  
we have the option of disabling it with the “doc_values” mapping parameter.
But why and when would you do this?
The main reason for doing this would be to save disk space, because this data structure
would then not be built and stored on disk.
Storing data in multiple data structures effectively duplicates data with the purpose of fast retrieval,
so disk space is traded for speed.

<span style="color:yellow">So when would you want to disable doc values? </span>
If you know that you won’t need to use a field for sorting, aggregations, and scripting,
you can disable doc values and save the disk space required to store this data structure.

- Next up, we have a parameter named “norms". Norms refers to the storage of various normalization factors that are used to compute relevance scores. oftentimes we will want to not just apply a filter to documents, but also rank them based on how well they match a given query.  
Think of search results on Google, for instance.
The results on page five are naturally not as relevant as the ones on the first page.
That’s because they are sorted based on relevance, and the same is done for some queries in elasticsearch. Part of what enables Elasticsearch to calculate relevance scores for documents, is these norms. As with many other things, they are stored within Apache Lucene. What the “norms” mapping parameter enables us to do, is to disable these norms.  
 <span style="color: yellow;"> Why? </span>
Because they take up quite a lot of disk space, just like doc values do. Not storing norms saves disk space, but also removes the ability to use a field for relevance scoring.

- Next we have "index" parameter which we can set to false for fields which are not meant to be indexed. 
```JSON
{
   "server_id": {
       "type": "integer",
       "index" : false
   } 
}
```
- By default ```NULL``` values are ignored by elastic search but if we wan to enable the searching gor it we can do it by 
"null_value" 

- We also have a "copy_to" parameter.
```JSON
PUT /sales
{
    "mappings": {
        "properties": {
            "first_name": {
                "type": "text",
                "copy_to": "full_name"
            },
            "last_name":{
                "type": "text",
                "copy_to": "full_name"
            },
            "full_name": {
                "type":"text",
            }
        }
    }
}
```
One important thing to note is that the copied values will not be part of the “_source” object.